#include <Wire.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#define F_CPU 16500000UL
volatile byte* adc_val_ptr;
float adc_val;

void adc_setup(){
 DDRB|=(1<<PB2);         //PB2 as output to activate LED
 ADCSRA|=(1<<ADEN);      //Enable ADC module
 ADMUX = 0b00000011; // configuring PB3 to take input
 ADCSRB=0x00;           //Configuring free running mode
 ADCSRA|=(1<<ADSC)|(1<<ADATE);   //Start ADC conversion and enabling Auto trigger
//(PB3, INPUT);
// DDRB|=(1<<PB1);
// TCCR0A=0x00;             //Timer0 normal mode
// TCCR0B=0x00;
// TCCR0B |= (1<<CS00)|(1<<CS02);   //prescaling with 1024
// TCNT0=0;
// ADCSRA|=(1<<ADEN);       //Enable ADC module
// ADMUX=0x01; // configuring PB2 to take input
// ADCSRB|=1<<ADTS2;   //Timer / Counter 0 overflow triggers the ADC to perform conversion
// ADCSRA|=(1<<ADSC)|(1<<ADATE); //Enabling start of conversion and Auto triggers
}

void requestEvent() {
  Wire.write((byte*)&adc_val, 4);
}
void setup() {
  adc_setup();
  Wire.begin(0x02);
}
void loop(){
    adc_val=(ADCH<<8)|ADCL;   //Reading ADCH and combining the data
//  if (adc_val>=0&&adc_val<=2000) //Lights up the LED under certain voltage 2.25 to 5+ level
//   PORTB|=(1<<PB1);  //LED remain ON
//  else{        //blink condition 
//    PORTB &=~(1<<PB1); //LED toggle
//  }
ADCSRA|=(1<<ADIF);
Wire.onRequest(requestEvent);
}
